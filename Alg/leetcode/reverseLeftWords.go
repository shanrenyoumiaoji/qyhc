func TestAlg1010(t *testing.T) {
	s := "abcdefg"
	k := 2
	fmt.Println(reverseLeftWords(s, k))
}

//剑指 Offer 58 - II. 左旋转字符串
func reverseLeftWords(s string, n int) string {
	return s[n:] + s[:n]

	//第二种 不利用切片
	var str string
	var str2 string
	for i := 0; i < len(s); i++ {
		if i < n {
			str += string(s[i])
		} else {
			str2 += string(s[i])
		}
	}

	return str2 + str
}

### Redis持久化(AOF和RDB)
#### AOF(记录的是操作命令)
- 持久化机制(先写内存,后写日志(写日志顺序写,写磁盘随机写))
	1. AOF写日志时不进行语法检查(若先写log,则会造成log记录了错误的语法)
	2. 日志只记录成功的命令
	3. 执行完再记录不会阻塞当前写操作(把日志写到磁盘时,如果磁盘压力很大会写盘很慢)
	4. AOF写日志时,是在主线程完成
- AOF写回策略(写日志策略、如何控制AOF日志写回的时机?appendfsync的配置项如下)
	1. Always,同步写回：每个写命令执行完，立马同步地将日志写回磁盘
	2. Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘
	3. No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
- AOF过大问题与处理
	1. 文件系统本身对文件大小有限制。 文件太大,再追加命令记录,效率会变低。如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用
	2. AOF重写机制(**由后台子进程bgrewriteaof来完成**),对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态，从而实现对 某个键值对 重复操作后产生的多条操作记录压缩成一条 的效果。进而实现压缩AOF文件的大小
		1. fork子进程时，子进程是会拷贝父进程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了父进程页表，也能共享访问父进程的内存数据了，此时，类似于有了父进程的所有内存数据
	3. 触发AOF重写 同时超出auto-aof-rewrite-min-size和auto-aof-rewrite-percentage或手动执行BGREWRITEAOF
#### RDB(二进制数据)
- RDB生成快照(save和bgsave)
	1. save：在主线程中执行，会导致阻塞。bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置
- RDB快照时数据是否能修改
	1. Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作
		1. redis 生成rdb 时候会fork 子进程。此时的读写操作： 读：主线程和bgsave子进程互不影响。 写：被修改的数据会被复制一份为副本，bgsave 把副本数据写入rdb 文件，主线程修改原数据
		2. “这块数据就会被复制一份，生成该数据的副本”，这个操作在实际执行过程中，是子进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数据，而当有新数据写入或数据修改时，主线程会把新数据或修改后的数据写到一个新的物理内存地址上，并修改主线程自己的页表映射。所以，子进程读到的类似于原始数据的一个副本，而主线程也可以正常进行修改
	imt图片插入
- 多久一次RDB快照
	1. 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环
	2. bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了
	3. 增量快照
	4 混合使用RDB和AOF,在两次快照直接,利用AOF记录日志记录,等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了
#### AOF 和 RDB 的选择问题
- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择
- 如果允许分钟级别的数据丢失，可以只使用 RDB
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡







