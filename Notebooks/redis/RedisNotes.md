## redis重点知识
#### Redis支持类型和底层数据结构关系
  ![](./images/redis底层数据和redis类型关系图.png)
#### Redis和DB数据一致性问题
当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。
#### Redis并发访问
**原子操作** : 利用Redis中原子单命令操作(INCR/DECR/SET等),或者把多个操作写到LUA脚本中执行

**加锁** : 加锁操作setnx或者set+lua(释放锁时)**加锁导致并发降低且加锁业务逻辑复杂**

#### Redis事务注意事项(MULTI、EXEC)
- 命令入队时就报错(例如redis中没有的命令PUT)
    1. 在这种情况下，事务本身就会被放弃执行,这种情况事务会回滚
- 命令入队时没报错，实际执行时报错(LPOP操作字符串类型)
    1. 有错误的命令不会被执行，正确的命令可以正常执行
- EXEC 命令执行时实例发生故障
    1. 如果开启了 AOF 日志，可以保证原子性。如果没有开启RDB和AOF也可以保障原子性

#### Redis数据不一致
- 主从数据不一致
    1. 主从同步传输延迟, 即使从库及时收到了主库的命令,但是从库如果在执行其他复杂的逻辑(例如集合操作命令)而阻塞
  
    **解决方法** : 要尽量保证主从库间的网络连接状况良好。例如，我们要避免把
    主从库部署在不同的机房，或者是避免把网络通信密集的应用（例如数据分析应用）和 Redis
     主从库部署在一起
- Redis集群中读到过期数据(删除数据只在主库,从库不会执行删除)
    1. Redis 的过期数据删除策略造成,Redis 同时使用了两种策略来删除过期的数据，分别是惰性删除策略和定期删除策略
        惰性删除策略: 数据过期后不会立即删除,等再次读取这个数据时才会删除
        定期删除策略: Redis每隔一段时间(默认100ms),随机选择一些数据检查是否过期
        注意:  Redis 3.2 之前的版本，那么，从库在服务读请求时，并不会判断数据是否过期，而是会返回过期数据。在 3.2 版本后，Redis 做了改进，如果读取的数据已经过期了，从库虽然不会删除，但是会返回空值，这就避免了客户端读到过期数据。所以，在应用主从集群时，尽量使用 Redis 3.2 及以上版本。

    **解决方法** : 使用 Redis 3.2 及以上版本。使用 EXPIREAT/PEXPIREAT 命令设置过期时间，避免从库上的数据过期时间滞后

#### 缓存击穿、穿透、雪崩
**缓存击穿**: 请求热点key时,无法在缓存中处理(或者热点key过期瞬间,大量请求),导致请求打到DB上
- 原因1: Redis中热点key瞬间失效
    1. **热点key不设置过期时间**
    2. **互斥锁** : 现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存
    
**缓存穿透**: 指要访问的数据既不在 Redis 缓存中，也不在数据库中
- 原因1: 业务层误操作,缓存中的数据和数据库中的数据被误删除了
- 原因2: 恶意攻击,专门访问数据库中没有的数据
    1. 缓存空值或缺省值
    2. 使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力（判断数据不在布隆过滤器中，一定不在数据库中，直接返回。判断在布隆过滤器中，可能误判，不一定在数据库中，若不在数据库中仍然发生缓存穿透，然后缓存空值或缺省值。）

**缓存雪崩**: 指大量的应用请求在无法在Redis中处理,紧接着请求打到DB上,导致DB压力激增
- 原因1: Redis中大量key同时过期
    1. **避免key同时失效** : 如果业务上确实要求有些数据同时失效,则可以用Expire给每个数据设置过期时间时额外增加一个随机值(例如增加1-3分钟)
    2. **服务降级(针对不同数据采取不同处理方式)** : 当业务访问非核心数据(例如电商商品属性),则可以暂停从Redis中查询,直接返回预定义信息、空值、错误信息等(根据具体业务环境返回),若是核心业务时,则仍然可以访问Redis和DB
    3. **数据预热** : 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。可以通过缓存reload机制，预先去更新缓存，在即将发生大并发访问前手动触发加载缓存不同的key**定时更新缓存策略双层缓存策略** : 实效性要求不高的缓存，容器启动初始化加载，采用定时任务更新或移除缓存
    4. **双层缓存策略** : C1为原始缓存，C2为拷贝缓存，C1失效时，可以访问C2，C1缓存失效时间设置为短期，C2设置为长期
    5. **加锁排队** : mutex互斥锁解决，Redis的SETNX去set一个mutex key，当操作返回成功时，再进行加载数据库的操作并回设缓存，否则，就重试整个get缓存的方法
    6. **设置不同的过期时间，让缓存失效的时间点尽量均匀** 
- 原因2: Redis宕机
    1. **服务熔断** : 业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统
    2. **请求限流** : 业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库
    3. **Redis高可用** : redis配置主从、哨兵、集群等
    
#### Redis问题汇总

